{
  "language": "Solidity",
  "sources": {
    "contracts/BCUBEPrivateSale.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/drafts/SignedSafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/crowdsale/Crowdsale.sol\";\nimport \"@openzeppelin/contracts/crowdsale/validation/TimedCrowdsale.sol\";\nimport \"@openzeppelin/contracts/crowdsale/validation/WhitelistCrowdsale.sol\";\nimport \"@chainlink/contracts/src/v0.5/interfaces/AggregatorV3Interface.sol\";\n\n/**\n * @title BCUBE Private Sale contract\n * @author Smit Rajput @ b-cube.ai\n **/\n\ncontract BCUBEPrivateSale is TimedCrowdsale, WhitelistCrowdsale {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n\n    /// @dev allowance is # of BCUBE each participant can withdraw from treasury.\n    /// @param currentAllowance this allowance is in 4 stages tracked by currentAllowance\n    /// @param shareWithdrawn tracks the amount of BCUBE already withdrawn from treasury\n    /// @param dollarUnitsPayed 1 dollar = 100,000,000 dollar units. This tracks dollar units payed by user to this contract\n    /// @param allocatedBcube amount of BCUBE allocated to this user\n    struct UserInfo {\n        uint256 dollarUnitsPayed;\n        uint256 allocatedBcube;\n        uint256 currentAllowance;\n        uint256 shareWithdrawn;\n    }\n\n    mapping(address => UserInfo) public bcubeAllocationRegistry;\n    uint256 public netAllocatedBcube;\n    uint256 public constant HARD_CAP = 10_000_000e18;\n\n    /// @dev variables whose instance fetch prices of USDT, ETH from Chainlink oracles\n    AggregatorV3Interface internal priceFeedETH;\n    AggregatorV3Interface internal priceFeedUSDT;\n\n    IERC20 public usdt;\n\n    event LogEtherReceived(address indexed sender, uint256 value);\n    event LogBcubeBuyUsingEth(\n        address indexed buyer,\n        uint256 incomingWei,\n        uint256 allocation\n    );\n    event LogBcubeBuyUsingUsdt(\n        address indexed buyer,\n        uint256 incomingUsdtUnits,\n        uint256 allocation\n    );\n    event LogETHPriceFeedChange(address indexed newChainlinkETHPriceFeed);\n    event LogUSDTPriceFeedChange(address indexed newChainlinkUSDTPriceFeed);\n    event LogUSDTInstanceChange(address indexed newUsdtContract);\n    event LogPrivateSaleTimeExtension(\n        uint256 previousClosingTime,\n        uint256 newClosingTime\n    );\n\n    /// @dev ensuring BCUBE allocations in private sale don't exceed 10m\n    modifier tokensRemaining() {\n        require(netAllocatedBcube < HARD_CAP, \"All tokens allocated\");\n        _;\n    }\n\n    function() external payable {\n        emit LogEtherReceived(_msgSender(), msg.value);\n    }\n\n    /**\n     * @param wallet_ team's address which receives ETH, USDT from users\n     * @param token_ BCUBE token address\n     * @param openingTime_ private sale starting time\n     * @param closingTime_ private sale closing time\n     * @dev first argument of Crowdsale is dummy rate for the parent contract which is\n     * not used for this contract\n     */\n    constructor(\n        address payable wallet_,\n        IERC20 token_,\n        uint256 openingTime_,\n        uint256 closingTime_,\n        address _chainlinkETHPriceFeed,\n        address _chainlinkUSDTPriceFeed,\n        address _usdtContract\n    )\n        public\n        TimedCrowdsale(openingTime_, closingTime_)\n        Crowdsale(1, wallet_, token_)\n    {\n        priceFeedETH = AggregatorV3Interface(_chainlinkETHPriceFeed);\n        priceFeedUSDT = AggregatorV3Interface(_chainlinkUSDTPriceFeed);\n        usdt = IERC20(_usdtContract);\n    }\n\n    /// @dev dummy rate for the parent contract which is not used for this contract\n    function rate() public view returns (uint256) {\n        revert(\"BCubePrivateSale: rate() called\");\n    }\n\n    /// @dev token buying function of the parent contract which is not used for this contract\n    function buyTokens() public pure returns (uint256) {\n        revert(\"BCubePrivateSale: buyTokens() called\");\n    }\n\n    /// @dev fetching ETH price from chainlink oracle\n    function fetchETHPrice() public view returns (int256) {\n        (, int256 price, , , ) = priceFeedETH.latestRoundData();\n        return price;\n    }\n\n    /// @dev fetching USDT price from chainlink oracle\n    function fetchUSDTPrice() public view returns (int256) {\n        (, int256 price, , , ) = priceFeedUSDT.latestRoundData();\n        int256 ethUSD = fetchETHPrice();\n        return price.mul(ethUSD).div(1e18);\n    }\n\n    /// @dev rate i.e. number of BCUBE units (wBCUBE from now) per dollar unit, offer to private investors\n    /// @return 2nd parameter is the number representing the current stage of the sale\n    /// @dev rates for stage 3, 4 are (200/9 * 10**10) and (200/11 * 10**10)\n    function calcRate() private view returns (uint256, uint8) {\n        if (netAllocatedBcube < 2_500_000e18) {\n            return (25e10, 1);\n        } else if (netAllocatedBcube < 5_000_000e18) {\n            return (222222222222, 2);\n        } else if (netAllocatedBcube < 7_500_000e18) {\n            return (20e10, 3);\n        } else if (netAllocatedBcube <= 10_000_000e18) {\n            return (181818181818, 4);\n        }\n    }\n\n    /// @dev allowing resetting ETH, USDT priceFeed instances, in case current Chainlink contracts upgrade\n    function setETHPriceFeed(address _newChainlinkETHPriceFeed)\n        external\n        onlyWhitelistAdmin\n    {\n        priceFeedETH = AggregatorV3Interface(_newChainlinkETHPriceFeed);\n        emit LogETHPriceFeedChange(_newChainlinkETHPriceFeed);\n    }\n\n    function setUSDTPriceFeed(address _newChainlinkUSDTPriceFeed)\n        external\n        onlyWhitelistAdmin\n    {\n        priceFeedUSDT = AggregatorV3Interface(_newChainlinkUSDTPriceFeed);\n        emit LogUSDTPriceFeedChange(_newChainlinkUSDTPriceFeed);\n    }\n\n    /// @dev allowing resetting USDT instance, in case current contract upgrades\n    function setUSDTInstance(address _newUsdtContract)\n        external\n        onlyWhitelistAdmin\n    {\n        usdt = IERC20(_newUsdtContract);\n        emit LogUSDTInstanceChange(_newUsdtContract);\n    }\n\n    /// @dev to extend the current closing time of private sale\n    function extendClosingTime(uint256 _newClosingTime)\n        external\n        onlyWhitelistAdmin\n    {\n        _extendTime(_newClosingTime);\n        emit LogPrivateSaleTimeExtension(closingTime(), _newClosingTime);\n    }\n\n    /// @dev allowing users to allocate BCUBEs for themselves using ETH\n    /// only KYC/AML whitelisted users can call this, while the sale is open and allocation hard cap is not reached\n    /// @dev it fetches current price of ETH, multiples that by incoming ETH to calc total incoming dollar units, then\n    /// allocates appropriate amount of BCUBE to user based on current rate, stage\n    function buyBcubeUsingETH()\n        external\n        payable\n        onlyWhitelisted\n        onlyWhileOpen\n        tokensRemaining\n    {\n        uint256 allocation;\n        uint256 ethPrice = uint256(fetchETHPrice());\n        uint256 dollarUnits = ethPrice.mul(msg.value).div(1e18);\n        super._preValidatePurchase(_msgSender(), msg.value);\n        allocation = executeAllocation(dollarUnits);\n        _forwardFunds();\n        emit LogBcubeBuyUsingEth(_msgSender(), msg.value, allocation);\n    }\n\n    /// @dev allowing users to allocate BCUBEs for themselves using USDT\n    /// does all things similar to the above function, but for USDT\n    function buyBcubeUsingUSDT(uint256 incomingUsdt)\n        external\n        onlyWhitelisted\n        onlyWhileOpen\n        tokensRemaining\n    {\n        uint256 allocation;\n        uint256 usdtPrice = uint256(fetchUSDTPrice());\n        uint256 dollarUnits = usdtPrice.mul(incomingUsdt).div(1e6);\n        super._preValidatePurchase(_msgSender(), incomingUsdt);\n        allocation = executeAllocation(dollarUnits);\n        usdt.safeTransferFrom(_msgSender(), wallet(), incomingUsdt);\n        emit LogBcubeBuyUsingUsdt(_msgSender(), incomingUsdt, allocation);\n    }\n\n    /// @dev stageCap is max net BCUBEs allocated until a given stage i.e. 2.5m, 5m, 7.5m, 10m for stages 1,2,3,4\n    /// @dev based on current netAllocatedBcube, fetches rate from calcRate()\n    /// then assigns minimum contribution for this round to minDollarUnits and checks it with the user\n    /// then checks for net contribution to be <= $25000 for the user\n    /// then calculates BCUBEs allocated to user from #BCUBE = rate * dollarUnits\n    /// => #wBCUBE = ((#wBCUBE / unit dollar) for this stage) * dollarUnits\n    /// Now, if new netAllocatedBcube does not exceed stageCap, the user is directly assigned their calculated BCUBE share\n    /// but if it exceeds the stage cap, then the user's BCUBE share for this stage remains same until stageCap (a1),\n    /// and the exceeding allocation is recalculated using rate of the next stage (a2)\n    /// then a1 + a2 is allocated to the user\n    /// Math for this can be found in the README\n    function executeAllocation(uint256 dollarUnits) private returns (uint256) {\n        uint256 finalAllocation;\n        uint256 bcubeAllocatedToUser;\n        uint256 minDollarUnits;\n        uint256 netUserDollarUnits;\n        uint256 rate_;\n        uint8 stage;\n        uint256 stageCap;\n        uint256 a1;\n        uint256 a2;\n        uint256 dollarUnitsUnused;\n        (rate_, stage) = calcRate();\n        stageCap = 2_500_000e18 * stage;\n        if (netAllocatedBcube <= 2_500_000e18) {\n            minDollarUnits = 1000_0000_0000;\n        } else if (netAllocatedBcube <= 5_000_000e18) {\n            minDollarUnits = 500_0000_0000;\n        } else if (netAllocatedBcube <= 7_500_000e18) {\n            minDollarUnits = 250_0000_0000;\n        } else if (netAllocatedBcube <= 10_000_000e18) {\n            minDollarUnits = 100_0000_0000;\n        }\n        require(\n            (minDollarUnits <= dollarUnits) && (dollarUnits <= 25000_0000_0000),\n            \"Contribution range for this round exceeded\"\n        );\n        netUserDollarUnits = bcubeAllocationRegistry[_msgSender()]\n            .dollarUnitsPayed\n            .add(dollarUnits);\n        require(\n            netUserDollarUnits <= 25000_0000_0000,\n            \"Contribution upper limit exceeded\"\n        );\n        bcubeAllocatedToUser = rate_.mul(dollarUnits);\n        finalAllocation = netAllocatedBcube.add(bcubeAllocatedToUser);\n        require(finalAllocation <= HARD_CAP, \"Hard cap exceeded\");\n        bcubeAllocationRegistry[_msgSender()]\n            .dollarUnitsPayed = netUserDollarUnits;\n        if (finalAllocation <= stageCap) {\n            netAllocatedBcube = finalAllocation;\n            bcubeAllocationRegistry[_msgSender()]\n                .allocatedBcube = bcubeAllocationRegistry[_msgSender()]\n                .allocatedBcube\n                .add(bcubeAllocatedToUser);\n            return bcubeAllocatedToUser;\n        } else {\n            uint256 total;\n            a1 = stageCap.sub(netAllocatedBcube);\n            dollarUnitsUnused = dollarUnits.sub(a1.div(rate_));\n            netAllocatedBcube = stageCap;\n            (rate_, stage) = calcRate();\n            a2 = dollarUnitsUnused.mul(rate_);\n            netAllocatedBcube = netAllocatedBcube.add(a2);\n            total = a1.add(a2);\n            bcubeAllocationRegistry[_msgSender()]\n                .allocatedBcube = bcubeAllocationRegistry[_msgSender()]\n                .allocatedBcube\n                .add(total);\n            return total;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/crowdsale/Crowdsale.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../GSN/Context.sol\";\nimport \"../token/ERC20/IERC20.sol\";\nimport \"../math/SafeMath.sol\";\nimport \"../token/ERC20/SafeERC20.sol\";\nimport \"../utils/ReentrancyGuard.sol\";\n\n/**\n * @title Crowdsale\n * @dev Crowdsale is a base contract for managing a token crowdsale,\n * allowing investors to purchase tokens with ether. This contract implements\n * such functionality in its most fundamental form and can be extended to provide additional\n * functionality and/or custom behavior.\n * The external interface represents the basic interface for purchasing tokens, and conforms\n * the base architecture for crowdsales. It is *not* intended to be modified / overridden.\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\n * the methods to add functionality. Consider using 'super' where appropriate to concatenate\n * behavior.\n */\ncontract Crowdsale is Context, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // The token being sold\n    IERC20 private _token;\n\n    // Address where funds are collected\n    address payable private _wallet;\n\n    // How many token units a buyer gets per wei.\n    // The rate is the conversion between wei and the smallest and indivisible token unit.\n    // So, if you are using a rate of 1 with a ERC20Detailed token with 3 decimals called TOK\n    // 1 wei will give you 1 unit, or 0.001 TOK.\n    uint256 private _rate;\n\n    // Amount of wei raised\n    uint256 private _weiRaised;\n\n    /**\n     * Event for token purchase logging\n     * @param purchaser who paid for the tokens\n     * @param beneficiary who got the tokens\n     * @param value weis paid for purchase\n     * @param amount amount of tokens purchased\n     */\n    event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n\n    /**\n     * @param rate Number of token units a buyer gets per wei\n     * @dev The rate is the conversion between wei and the smallest and indivisible\n     * token unit. So, if you are using a rate of 1 with a ERC20Detailed token\n     * with 3 decimals called TOK, 1 wei will give you 1 unit, or 0.001 TOK.\n     * @param wallet Address where collected funds will be forwarded to\n     * @param token Address of the token being sold\n     */\n    constructor (uint256 rate, address payable wallet, IERC20 token) public {\n        require(rate > 0, \"Crowdsale: rate is 0\");\n        require(wallet != address(0), \"Crowdsale: wallet is the zero address\");\n        require(address(token) != address(0), \"Crowdsale: token is the zero address\");\n\n        _rate = rate;\n        _wallet = wallet;\n        _token = token;\n    }\n\n    /**\n     * @dev fallback function ***DO NOT OVERRIDE***\n     * Note that other contracts will transfer funds with a base gas stipend\n     * of 2300, which is not enough to call buyTokens. Consider calling\n     * buyTokens directly when purchasing tokens from a contract.\n     */\n    function () external payable {\n        buyTokens(_msgSender());\n    }\n\n    /**\n     * @return the token being sold.\n     */\n    function token() public view returns (IERC20) {\n        return _token;\n    }\n\n    /**\n     * @return the address where funds are collected.\n     */\n    function wallet() public view returns (address payable) {\n        return _wallet;\n    }\n\n    /**\n     * @return the number of token units a buyer gets per wei.\n     */\n    function rate() public view returns (uint256) {\n        return _rate;\n    }\n\n    /**\n     * @return the amount of wei raised.\n     */\n    function weiRaised() public view returns (uint256) {\n        return _weiRaised;\n    }\n\n    /**\n     * @dev low level token purchase ***DO NOT OVERRIDE***\n     * This function has a non-reentrancy guard, so it shouldn't be called by\n     * another `nonReentrant` function.\n     * @param beneficiary Recipient of the token purchase\n     */\n    function buyTokens(address beneficiary) public nonReentrant payable {\n        uint256 weiAmount = msg.value;\n        _preValidatePurchase(beneficiary, weiAmount);\n\n        // calculate token amount to be created\n        uint256 tokens = _getTokenAmount(weiAmount);\n\n        // update state\n        _weiRaised = _weiRaised.add(weiAmount);\n\n        _processPurchase(beneficiary, tokens);\n        emit TokensPurchased(_msgSender(), beneficiary, weiAmount, tokens);\n\n        _updatePurchasingState(beneficiary, weiAmount);\n\n        _forwardFunds();\n        _postValidatePurchase(beneficiary, weiAmount);\n    }\n\n    /**\n     * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met.\n     * Use `super` in contracts that inherit from Crowdsale to extend their validations.\n     * Example from CappedCrowdsale.sol's _preValidatePurchase method:\n     *     super._preValidatePurchase(beneficiary, weiAmount);\n     *     require(weiRaised().add(weiAmount) <= cap);\n     * @param beneficiary Address performing the token purchase\n     * @param weiAmount Value in wei involved in the purchase\n     */\n    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {\n        require(beneficiary != address(0), \"Crowdsale: beneficiary is the zero address\");\n        require(weiAmount != 0, \"Crowdsale: weiAmount is 0\");\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n    }\n\n    /**\n     * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid\n     * conditions are not met.\n     * @param beneficiary Address performing the token purchase\n     * @param weiAmount Value in wei involved in the purchase\n     */\n    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends\n     * its tokens.\n     * @param beneficiary Address performing the token purchase\n     * @param tokenAmount Number of tokens to be emitted\n     */\n    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {\n        _token.safeTransfer(beneficiary, tokenAmount);\n    }\n\n    /**\n     * @dev Executed when a purchase has been validated and is ready to be executed. Doesn't necessarily emit/send\n     * tokens.\n     * @param beneficiary Address receiving the tokens\n     * @param tokenAmount Number of tokens to be purchased\n     */\n    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {\n        _deliverTokens(beneficiary, tokenAmount);\n    }\n\n    /**\n     * @dev Override for extensions that require an internal state to check for validity (current user contributions,\n     * etc.)\n     * @param beneficiary Address receiving the tokens\n     * @param weiAmount Value in wei involved in the purchase\n     */\n    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Override to extend the way in which ether is converted to tokens.\n     * @param weiAmount Value in wei to be converted into tokens\n     * @return Number of tokens that can be purchased with the specified _weiAmount\n     */\n    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {\n        return weiAmount.mul(_rate);\n    }\n\n    /**\n     * @dev Determines how ETH is stored/forwarded on purchases.\n     */\n    function _forwardFunds() internal {\n        _wallet.transfer(msg.value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/drafts/SignedSafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private INT256_MIN = -2**255;\n\n    /**\n     * @dev Multiplies two signed integers, reverts on overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two signed integers, reverts on overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two signed integers, reverts on overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/SafeCast.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\n/**\n * @dev Wrappers over Solidity's uintXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and then downcasting.\n *\n * _Available since v2.5.0._\n */\nlibrary SafeCast {\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return uint8(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/crowdsale/validation/TimedCrowdsale.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../math/SafeMath.sol\";\nimport \"../Crowdsale.sol\";\n\n/**\n * @title TimedCrowdsale\n * @dev Crowdsale accepting contributions only within a time frame.\n */\ncontract TimedCrowdsale is Crowdsale {\n    using SafeMath for uint256;\n\n    uint256 private _openingTime;\n    uint256 private _closingTime;\n\n    /**\n     * Event for crowdsale extending\n     * @param newClosingTime new closing time\n     * @param prevClosingTime old closing time\n     */\n    event TimedCrowdsaleExtended(uint256 prevClosingTime, uint256 newClosingTime);\n\n    /**\n     * @dev Reverts if not in crowdsale time range.\n     */\n    modifier onlyWhileOpen {\n        require(isOpen(), \"TimedCrowdsale: not open\");\n        _;\n    }\n\n    /**\n     * @dev Constructor, takes crowdsale opening and closing times.\n     * @param openingTime Crowdsale opening time\n     * @param closingTime Crowdsale closing time\n     */\n    constructor (uint256 openingTime, uint256 closingTime) public {\n        // solhint-disable-next-line not-rely-on-time\n        require(openingTime >= block.timestamp, \"TimedCrowdsale: opening time is before current time\");\n        // solhint-disable-next-line max-line-length\n        require(closingTime > openingTime, \"TimedCrowdsale: opening time is not before closing time\");\n\n        _openingTime = openingTime;\n        _closingTime = closingTime;\n    }\n\n    /**\n     * @return the crowdsale opening time.\n     */\n    function openingTime() public view returns (uint256) {\n        return _openingTime;\n    }\n\n    /**\n     * @return the crowdsale closing time.\n     */\n    function closingTime() public view returns (uint256) {\n        return _closingTime;\n    }\n\n    /**\n     * @return true if the crowdsale is open, false otherwise.\n     */\n    function isOpen() public view returns (bool) {\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp >= _openingTime && block.timestamp <= _closingTime;\n    }\n\n    /**\n     * @dev Checks whether the period in which the crowdsale is open has already elapsed.\n     * @return Whether crowdsale period has elapsed\n     */\n    function hasClosed() public view returns (bool) {\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp > _closingTime;\n    }\n\n    /**\n     * @dev Extend parent behavior requiring to be within contributing period.\n     * @param beneficiary Token purchaser\n     * @param weiAmount Amount of wei contributed\n     */\n    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal onlyWhileOpen view {\n        super._preValidatePurchase(beneficiary, weiAmount);\n    }\n\n    /**\n     * @dev Extend crowdsale.\n     * @param newClosingTime Crowdsale closing time\n     */\n    function _extendTime(uint256 newClosingTime) internal {\n        require(!hasClosed(), \"TimedCrowdsale: already closed\");\n        // solhint-disable-next-line max-line-length\n        require(newClosingTime > _closingTime, \"TimedCrowdsale: new closing time is before current closing time\");\n\n        emit TimedCrowdsaleExtended(_closingTime, newClosingTime);\n        _closingTime = newClosingTime;\n    }\n}\n"
    },
    "@openzeppelin/contracts/crowdsale/validation/WhitelistCrowdsale.sol": {
      "content": "pragma solidity ^0.5.0;\nimport \"../Crowdsale.sol\";\nimport \"../../access/roles/WhitelistedRole.sol\";\n\n\n/**\n * @title WhitelistCrowdsale\n * @dev Crowdsale in which only whitelisted users can contribute.\n */\ncontract WhitelistCrowdsale is WhitelistedRole, Crowdsale {\n    /**\n     * @dev Extend parent behavior requiring beneficiary to be whitelisted. Note that no\n     * restriction is imposed on the account sending the transaction.\n     * @param _beneficiary Token beneficiary\n     * @param _weiAmount Amount of wei contributed\n     */\n    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal view {\n        require(isWhitelisted(_beneficiary), \"WhitelistCrowdsale: beneficiary doesn't have the Whitelisted role\");\n        super._preValidatePurchase(_beneficiary, _weiAmount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@chainlink/contracts/src/v0.5/interfaces/AggregatorV3Interface.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\n * metering changes introduced in the Istanbul hardfork.\n */\ncontract ReentrancyGuard {\n    bool private _notEntered;\n\n    constructor () internal {\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive, but in exchange the refund on every call to nonReentrant\n        // will be lower in amount. Since refunds are capped to a percetange of\n        // the total transaction's gas, it is best to keep them low in cases\n        // like this one, to increase the likelihood of the full refund coming\n        // into effect.\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.5.5;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following \n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/roles/WhitelistedRole.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"../Roles.sol\";\nimport \"./WhitelistAdminRole.sol\";\n\n/**\n * @title WhitelistedRole\n * @dev Whitelisted accounts have been approved by a WhitelistAdmin to perform certain actions (e.g. participate in a\n * crowdsale). This role is special in that the only accounts that can add it are WhitelistAdmins (who can also remove\n * it), and not Whitelisteds themselves.\n */\ncontract WhitelistedRole is Context, WhitelistAdminRole {\n    using Roles for Roles.Role;\n\n    event WhitelistedAdded(address indexed account);\n    event WhitelistedRemoved(address indexed account);\n\n    Roles.Role private _whitelisteds;\n\n    modifier onlyWhitelisted() {\n        require(isWhitelisted(_msgSender()), \"WhitelistedRole: caller does not have the Whitelisted role\");\n        _;\n    }\n\n    function isWhitelisted(address account) public view returns (bool) {\n        return _whitelisteds.has(account);\n    }\n\n    function addWhitelisted(address account) public onlyWhitelistAdmin {\n        _addWhitelisted(account);\n    }\n\n    function removeWhitelisted(address account) public onlyWhitelistAdmin {\n        _removeWhitelisted(account);\n    }\n\n    function renounceWhitelisted() public {\n        _removeWhitelisted(_msgSender());\n    }\n\n    function _addWhitelisted(address account) internal {\n        _whitelisteds.add(account);\n        emit WhitelistedAdded(account);\n    }\n\n    function _removeWhitelisted(address account) internal {\n        _whitelisteds.remove(account);\n        emit WhitelistedRemoved(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Roles.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/roles/WhitelistAdminRole.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"../Roles.sol\";\n\n/**\n * @title WhitelistAdminRole\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\n */\ncontract WhitelistAdminRole is Context {\n    using Roles for Roles.Role;\n\n    event WhitelistAdminAdded(address indexed account);\n    event WhitelistAdminRemoved(address indexed account);\n\n    Roles.Role private _whitelistAdmins;\n\n    constructor () internal {\n        _addWhitelistAdmin(_msgSender());\n    }\n\n    modifier onlyWhitelistAdmin() {\n        require(isWhitelistAdmin(_msgSender()), \"WhitelistAdminRole: caller does not have the WhitelistAdmin role\");\n        _;\n    }\n\n    function isWhitelistAdmin(address account) public view returns (bool) {\n        return _whitelistAdmins.has(account);\n    }\n\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\n        _addWhitelistAdmin(account);\n    }\n\n    function renounceWhitelistAdmin() public {\n        _removeWhitelistAdmin(_msgSender());\n    }\n\n    function _addWhitelistAdmin(address account) internal {\n        _whitelistAdmins.add(account);\n        emit WhitelistAdminAdded(account);\n    }\n\n    function _removeWhitelistAdmin(address account) internal {\n        _whitelistAdmins.remove(account);\n        emit WhitelistAdminRemoved(account);\n    }\n}\n"
    },
    "contracts/Treasury.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./BCUBEPrivateSale.sol\";\n\n/**\n * @title BCUBE Treasury\n * @notice Contract in which 50m BCUBE will be minted after private sale,\n * and distributed to stakeholders, in vested manner to whomever applicable\n * @author Smit Rajput @ b-cube.ai\n **/\n\ncontract Treasury is BCUBEPrivateSale {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /// @param shareWithdrawn amount of allocated BCUBEs withdrawn\n    /// @param currentAllowance amount of BCUBE that can be claimed from treasury increases 25% per 6 months (vesting),\n    /// currentAllowance tracks this increasing allowance\n    /// @param increaseInAllowance 25% of net allocation. By which currentAllowance increases per 6 months\n    struct Advisor {\n        uint256 increaseInAllowance;\n        uint256 currentAllowance;\n        uint256 shareWithdrawn;\n    }\n\n    mapping(address => Advisor) public advisors;\n\n    /// @notice team, devFund shares, like advisors' share are also vested, hence have their allowance\n    /// trackers similar to advisors', along with BCUBEs withdrawn tracker\n    uint256 public teamShareWithdrawn;\n    uint256 public teamAllowance;\n    uint256 public devFundShareWithdrawn;\n    uint256 public devFundAllowance;\n\n    /// @notice reserves, community, bounty, publicSale share of BCUBEs are not vested and only have their\n    /// BCUBEs withdrawn trackers\n    uint256 public reservesWithdrawn;\n    uint256 public communityShareWithdrawn;\n    uint256 public bountyWithdrawn;\n    uint256 public publicSaleShareWithdrawn;\n\n    /// @notice timestamp at which BCUBE will be listed on CEXes/DEXes\n    uint256 public listingTime;\n\n    event LogEtherReceived(address indexed sender, uint256 value);\n    event LogListingTimeChange(uint256 prevListingTime, uint256 newListingTime);\n    event LogAdvisorAddition(\n        address indexed newAdvisor,\n        uint256 newNetAllowance\n    );\n    event LogAdvisorAllowanceChange(\n        address indexed advisor,\n        uint256 prevNetAllowance,\n        uint256 newNetAllowance\n    );\n    event LogAdvisorRemoval(address indexed removedAdvisor);\n    event LogAdvisorShareWithdrawn(\n        address indexed advisor,\n        uint256 bcubeAmountWithdrawn\n    );\n    event LogTeamShareWithdrawn(uint256 bcubeAmountWithdrawn);\n    event LogDevFundShareWithdrawn(uint256 bcubeAmountWithdrawn);\n    event LogReservesShareWithdrawn(uint256 bcubeAmountWithdrawn);\n    event LogCommunityShareWithdrawn(uint256 bcubeAmountWithdrawn);\n    event LogBountyShareWithdrawn(uint256 bcubeAmountWithdrawn);\n    event LogPublicSaleShareWithdrawn(uint256 bcubeAmountWithdrawn);\n    event LogPrivateSaleShareWithdrawn(\n        address indexed participant,\n        uint256 bcubeAmountWithdrawn\n    );\n\n    /// @dev wallet() is team's address, declared in the parent Crowdsale contract\n    modifier onlyTeam() {\n        require(_msgSender() == wallet(), \"Only team can call\");\n        _;\n    }\n\n    modifier onlyAfterListing() {\n        require(now >= listingTime, \"Only callable after listing\");\n        _;\n    }\n\n    function() external payable {\n        emit LogEtherReceived(_msgSender(), msg.value);\n    }\n\n    /// @param wallet_ team's address which controls all BCUBEs except private sale share\n    constructor(\n        address payable wallet_,\n        IERC20 token_,\n        uint256 openingTime_,\n        uint256 closingTime_,\n        address _chainlinkETHPriceFeed,\n        address _chainlinkUSDTPriceFeed,\n        address _usdtContract,\n        uint256 _listingTime\n    )\n        public\n        BCUBEPrivateSale(\n            wallet_,\n            token_,\n            openingTime_,\n            closingTime_,\n            _chainlinkETHPriceFeed,\n            _chainlinkUSDTPriceFeed,\n            _usdtContract\n        )\n    {\n        listingTime = _listingTime;\n    }\n\n    /// @dev WhitelistAdmin is the deployer\n    /// @dev allows deployer to change listingTime, before current listingTime\n    function setListingTime(uint256 _startTime) external onlyWhitelistAdmin {\n        require(now < listingTime, \"listingTime unchangable after listing\");\n        uint256 prevListingTime = listingTime;\n        listingTime = _startTime;\n        emit LogListingTimeChange(prevListingTime, listingTime);\n    }\n\n    function addAdvisor(address _newAdvisor, uint256 _netAllowance)\n        external\n        onlyWhitelistAdmin\n    {\n        require(_newAdvisor != address(0), \"Invalid advisor address\");\n        advisors[_newAdvisor].increaseInAllowance = _netAllowance.div(4);\n        emit LogAdvisorAddition(_newAdvisor, _netAllowance);\n    }\n\n    /// @dev allows deployer to change net allowance of existing advisor\n    function setAdvisorAllowance(address _advisor, uint256 _newNetAllowance)\n        external\n        onlyWhitelistAdmin\n    {\n        uint256 prevNetAllowance;\n        require(advisors[_advisor].increaseInAllowance > 0, \"Invalid advisor\");\n        prevNetAllowance = advisors[_advisor].increaseInAllowance.mul(4);\n        advisors[_advisor].increaseInAllowance = _newNetAllowance.div(4);\n        emit LogAdvisorAllowanceChange(\n            _advisor,\n            prevNetAllowance,\n            _newNetAllowance\n        );\n    }\n\n    function removeAdvisor(address _advisor) external onlyWhitelistAdmin {\n        require(advisors[_advisor].increaseInAllowance > 0, \"Invalid advisor\");\n        delete advisors[_advisor];\n        emit LogAdvisorRemoval(_advisor);\n    }\n\n    /// @dev allows existing advisors to withdraw their share of BCUBEs,\n    /// 25% per 6 months, after listingTime\n    function advisorShareWithdraw(uint256 bcubeAmount)\n        external\n        onlyAfterListing\n    {\n        uint256 allowance;\n        require(advisors[_msgSender()].increaseInAllowance > 0, \"!advisor\");\n        uint256 increase = advisors[_msgSender()].increaseInAllowance;\n        if (now >= listingTime + 104 weeks) allowance = increase.mul(4);\n        else if (now >= listingTime + 78 weeks) allowance = increase.mul(3);\n        else if (now >= listingTime + 52 weeks) allowance = increase.mul(2);\n        else if (now >= listingTime + 26 weeks) allowance = increase;\n        if (allowance != advisors[_msgSender()].currentAllowance)\n            advisors[_msgSender()].currentAllowance = allowance;\n        uint256 finalAdvisorShareWithdrawn;\n        finalAdvisorShareWithdrawn = advisors[_msgSender()].shareWithdrawn.add(\n            bcubeAmount\n        );\n        require(\n            finalAdvisorShareWithdrawn <=\n                advisors[_msgSender()].currentAllowance,\n            \"Out of advisor share\"\n        );\n        advisors[_msgSender()].shareWithdrawn = finalAdvisorShareWithdrawn;\n        token().safeTransfer(_msgSender(), bcubeAmount);\n        emit LogAdvisorShareWithdrawn(_msgSender(), bcubeAmount);\n    }\n\n    /// @dev allows team to withdraw devFund share of BCUBEs,\n    /// 25% of 7.5m, per 6 months, after listingTime\n    function devFundShareWithdraw(uint256 bcubeAmount)\n        external\n        onlyTeam\n        onlyAfterListing\n    {\n        uint256 allowance;\n        if (now >= listingTime + 104 weeks) allowance = 1_875_000e18 * 4;\n        else if (now >= listingTime + 78 weeks) allowance = 1_875_000e18 * 3;\n        else if (now >= listingTime + 52 weeks) allowance = 1_875_000e18 * 2;\n        else if (now >= listingTime + 26 weeks) allowance = 1_875_000e18;\n        if (allowance != devFundAllowance) devFundAllowance = allowance;\n        uint256 finalDevFundShareWithdrawn;\n        finalDevFundShareWithdrawn = devFundShareWithdrawn.add(bcubeAmount);\n        require(\n            finalDevFundShareWithdrawn <= devFundAllowance,\n            \"Out of dev fund share\"\n        );\n        devFundShareWithdrawn = finalDevFundShareWithdrawn;\n        token().safeTransfer(wallet(), bcubeAmount);\n        emit LogDevFundShareWithdrawn(bcubeAmount);\n    }\n\n    /// @dev allows team to withdraw their share of BCUBEs,\n    /// 12.5% of 5m, per 6 months, after listingTime\n    function teamShareWithdraw(uint256 bcubeAmount)\n        external\n        onlyTeam\n        onlyAfterListing\n    {\n        uint256 allowance;\n        if (now >= listingTime + 208 weeks) allowance = 625_000e18 * 8;\n        else if (now >= listingTime + 182 weeks) allowance = 625_000e18 * 7;\n        else if (now >= listingTime + 156 weeks) allowance = 625_000e18 * 6;\n        else if (now >= listingTime + 130 weeks) allowance = 625_000e18 * 5;\n        else if (now >= listingTime + 104 weeks) allowance = 625_000e18 * 4;\n        else if (now >= listingTime + 78 weeks) allowance = 625_000e18 * 3;\n        else if (now >= listingTime + 52 weeks) allowance = 625_000e18 * 2;\n        else if (now >= listingTime + 26 weeks) allowance = 625_000e18;\n        if (allowance != teamAllowance) teamAllowance = allowance;\n        uint256 finalTeamShareWithdrawn;\n        finalTeamShareWithdrawn = teamShareWithdrawn.add(bcubeAmount);\n        require(finalTeamShareWithdrawn <= teamAllowance, \"Out of team share\");\n        teamShareWithdrawn = finalTeamShareWithdrawn;\n        token().safeTransfer(wallet(), bcubeAmount);\n        emit LogTeamShareWithdrawn(bcubeAmount);\n    }\n\n    /// @dev allows team to withdraw reserves share of BCUBEs i.e. 7m after listingTime\n    function reservesShareWithdraw(uint256 bcubeAmount)\n        external\n        onlyTeam\n        onlyAfterListing\n    {\n        shareWithdraw(\n            bcubeAmount,\n            reservesWithdrawn,\n            7_000_000e18,\n            \"Out of reserves share\",\n            0\n        );\n        emit LogReservesShareWithdrawn(bcubeAmount);\n    }\n\n    /// @dev allows team to withdraw community share of BCUBEs i.e. 2.5m\n    function communityShareWithdraw(uint256 bcubeAmount) external onlyTeam {\n        shareWithdraw(\n            bcubeAmount,\n            communityShareWithdrawn,\n            2_500_000e18,\n            \"Out of community share\",\n            1\n        );\n        emit LogCommunityShareWithdrawn(bcubeAmount);\n    }\n\n    /// @dev allows team to withdraw bounty share of BCUBEs i.e. 0.5m\n    function bountyShareWithdraw(uint256 bcubeAmount) external onlyTeam {\n        shareWithdraw(\n            bcubeAmount,\n            bountyWithdrawn,\n            500_000e18,\n            \"Out of bounty share\",\n            2\n        );\n        emit LogBountyShareWithdrawn(bcubeAmount);\n    }\n\n    /// @dev allows team to withdraw publicSale share of BCUBEs i.e. 25m - (netAllocatedBcube in private sale)\n    function publicSaleShareWithdraw(uint256 bcubeAmount) external onlyTeam {\n        shareWithdraw(\n            bcubeAmount,\n            publicSaleShareWithdrawn,\n            25_000_000e18 - netAllocatedBcube,\n            \"Out of publicSale share\",\n            3\n        );\n        emit LogPublicSaleShareWithdrawn(bcubeAmount);\n    }\n\n    /// @dev common function which handles withdrawals for the immediate above 4 functions\n    /// it checks if the amount being withdrawn is below the allocated share, then updates the\n    /// appropriate tracker and performs the transfer\n    function shareWithdraw(\n        uint256 bcubeAmount,\n        uint256 specificShareWithdrawn,\n        uint256 cap,\n        string memory errMsg,\n        uint256 flag\n    ) private {\n        uint256 finalShareWithdrawn;\n        finalShareWithdrawn = specificShareWithdrawn.add(bcubeAmount);\n        require(finalShareWithdrawn <= cap, errMsg);\n        if (flag == 0) reservesWithdrawn = finalShareWithdrawn;\n        else if (flag == 1) communityShareWithdrawn = finalShareWithdrawn;\n        else if (flag == 2) bountyWithdrawn = finalShareWithdrawn;\n        else if (flag == 3) publicSaleShareWithdrawn = finalShareWithdrawn;\n        token().safeTransfer(wallet(), bcubeAmount);\n    }\n\n    /// @dev allows private sale participants to withdraw their allocated share of\n    /// BCUBEs, 25% per 30 days, after listingTime\n    function privateSaleShareWithdraw(uint256 bcubeAmount)\n        external\n        onlyAfterListing\n    {\n        require(\n            bcubeAllocationRegistry[_msgSender()].allocatedBcube > 0,\n            \"!privateSaleParticipant || 0 BCUBE allocated\"\n        );\n        uint256 allowance;\n        uint256 increase =\n            bcubeAllocationRegistry[_msgSender()].allocatedBcube.div(4);\n        if (now >= listingTime + 120 days) allowance = increase * 4;\n        else if (now >= listingTime + 90 days) allowance = increase * 3;\n        else if (now >= listingTime + 60 days) allowance = increase * 2;\n        else if (now >= listingTime + 30 days) allowance = increase;\n        if (allowance != bcubeAllocationRegistry[_msgSender()].currentAllowance)\n            bcubeAllocationRegistry[_msgSender()].currentAllowance = allowance;\n        uint256 finalPSSWithdrawn;\n        finalPSSWithdrawn = bcubeAllocationRegistry[_msgSender()]\n            .shareWithdrawn\n            .add(bcubeAmount);\n        require(\n            finalPSSWithdrawn <=\n                bcubeAllocationRegistry[_msgSender()].currentAllowance,\n            \"Insufficient allowance\"\n        );\n        bcubeAllocationRegistry[_msgSender()]\n            .shareWithdrawn = finalPSSWithdrawn;\n        token().safeTransfer(_msgSender(), bcubeAmount);\n        emit LogPrivateSaleShareWithdrawn(_msgSender(), bcubeAmount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n"
    },
    "contracts/Staking.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\n\n/**\n * @title Staking Contract\n * @notice Contract which allows users to stake their BCUBE tokens to gain access to\n * free services on the website\n * @author Smit Rajput @ b-cube.ai\n **/\n\ncontract Staking {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    mapping(address => uint256) public bcubeStakeRegistry;\n\n    IERC20 private bcube;\n\n    event LogEtherReceived(address indexed sender, uint256 weiReceived);\n    event LogBcubeStaking(address indexed staker, uint256 bcubeAmount);\n    event LogBcubeUnstaking(address indexed unstaker, uint256 bcubeAmount);\n\n    function() external payable {\n        emit LogEtherReceived(msg.sender, msg.value);\n    }\n\n    constructor(IERC20 _bcube) public {\n        bcube = _bcube;\n    }\n\n    function stake(uint256 _bcubeAmount) external {\n        require(_bcubeAmount > 0, \"Staking non-positive BCUBE\");\n        bcubeStakeRegistry[msg.sender] = bcubeStakeRegistry[msg.sender].add(\n            _bcubeAmount\n        );\n        bcube.safeTransferFrom(msg.sender, address(this), _bcubeAmount);\n        emit LogBcubeStaking(msg.sender, _bcubeAmount);\n    }\n\n    function unstake(uint256 _bcubeAmount) external {\n        require(_bcubeAmount > 0, \"Unstaking non-positive BCUBE\");\n        require(\n            bcubeStakeRegistry[msg.sender] >= _bcubeAmount,\n            \"Insufficient staked bcube\"\n        );\n        bcubeStakeRegistry[msg.sender] = bcubeStakeRegistry[msg.sender].sub(\n            _bcubeAmount\n        );\n        bcube.safeTransfer(msg.sender, _bcubeAmount);\n        emit LogBcubeUnstaking(msg.sender, _bcubeAmount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/ownership/Ownable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/BCUBEToken.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\";\n\n/**\n * @title BCUBE token contract\n * @notice Follows ERC-20 standards\n * @author Smit Rajput @ b-cube.ai\n **/\n\ncontract BCUBEToken is ERC20, ERC20Detailed, Ownable {\n    /// @notice total supply cap of BCUBE tokens\n    uint256 public cap;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 initialSupply,\n        uint256 _cap\n    ) public ERC20Detailed(_name, _symbol, _decimals) {\n        require(_cap > 0, \"ERC20Capped: cap is 0\");\n        cap = _cap;\n        _mint(msg.sender, initialSupply);\n    }\n\n    /// @dev minting implementation for BCUBEs, intended to be called only once i.e. after private sale\n    function mint(address account, uint256 amount) external onlyOwner {\n        require(totalSupply().add(amount) <= cap, \"ERC20Capped: cap exceeded\");\n        _mint(account, amount);\n    }\n\n    /// @dev only owner can burn tokens it already owns\n    function burn(uint256 amount) external onlyOwner {\n        _burn(owner(), amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}